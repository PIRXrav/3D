/*******************************************************************************
 * Includes
 ******************************************************************************/

#include "box3.h"
#include <assert.h>

/*******************************************************************************
 * Macros
 ******************************************************************************/

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))

/*******************************************************************************
 * Types
 ******************************************************************************/

/*******************************************************************************
 * Internal function declaration
 ******************************************************************************/

static Vector *BOX3_CalcCenter(Box3 *b);

/*******************************************************************************
 * Variables
 ******************************************************************************/

/*******************************************************************************
 * Public function
 ******************************************************************************/

void BOX3_Reset(Box3 *b) { b->cpt = 0; }

bool BOX3_IsPointInside(Box3 *b, Vector *point) {
  return b->cpt && point->x <= b->max.x && point->x >= b->min.x &&
         point->y <= b->max.y && point->y >= b->min.y && point->z <= b->max.z &&
         point->z >= b->min.z;
}

void BOX3_AddPoint(Box3 *b, Vector *point) {
  if (b->cpt) {
    b->max.x = MAX(b->max.x, point->x);
    b->max.y = MAX(b->max.y, point->y);
    b->max.z = MAX(b->max.z, point->z);
    b->min.x = MIN(b->min.x, point->x);
    b->min.y = MIN(b->min.y, point->y);
    b->min.z = MIN(b->min.z, point->z);
  } else {
    VECT_Cpy(&b->min, point);
    VECT_Cpy(&b->max, point);
  }
  b->cpt += 1;
  BOX3_CalcCenter(b);
}

static Vector *BOX3_CalcCenter(Box3 *b) {
  assert(b->cpt);
  b->center.x = (b->max.x + b->min.x) / 2;
  b->center.y = (b->max.y + b->min.y) / 2;
  b->center.z = (b->max.z + b->min.z) / 2;
  return &b->center;
}

/*******************************************************************************
 * Internal function
 ******************************************************************************/
